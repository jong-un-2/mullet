/**
 * Mars åˆçº¦ç›´æ¥é›†æˆ - PYUSD å­˜æ¬¾å’Œå–æ¬¾
 */

import { 
  Connection, 
  PublicKey, 
  Transaction, 
  TransactionInstruction,
  ComputeBudgetProgram,
} from '@solana/web3.js';
import { 
  TOKEN_2022_PROGRAM_ID,
  TOKEN_PROGRAM_ID,
  getAssociatedTokenAddressSync,
  createAssociatedTokenAccountInstruction,
} from '@solana/spl-token';
import { KaminoSDKHelper } from './kaminoSdkHelper';

// Mars åˆçº¦å¸¸é‡
export const MARS_PROGRAM_ID = new PublicKey("AEK6WoTp7vY6LM1ZDmedxXHoCkpJL1i86KD2qWzsaJx4");
export const KAMINO_V2_PROGRAM = new PublicKey("KvauGMspG5k6rtzrqqn7WNn3oZdyKqLKwK2XWQ8FLjd");
export const KLEND_PROGRAM = new PublicKey("KLend2g3cP87fffoy8q1mQqGKjrxjC8boSyAYavgmjD");
export const PYUSD_MINT = new PublicKey("2b1kV6DkPAnxd5ixfnxCpjxmKwqjjaYmCZfHsFu24GXo");
export const PYUSD_VAULT = new PublicKey("A2wsxhA7pF4B2UKVfXocb6TAAP9ipfPJam6oMKgDE5BK");
export const EVENT_AUTHORITY = new PublicKey("24tHwQyJJ9akVXxnvkekGfAoeUJXXS7mE6kQNioNySsK");

// Instruction discriminators
const DISCRIMINATOR_DEPOSIT_AND_STAKE = Buffer.from([42, 143, 36, 40, 74, 180, 200, 42]);
const DISCRIMINATOR_START_UNSTAKE = Buffer.from([69, 169, 100, 27, 224, 93, 160, 125]);
const DISCRIMINATOR_UNSTAKE = Buffer.from([147, 182, 155, 59, 74, 113, 23, 203]);
const DISCRIMINATOR_WITHDRAW = Buffer.from([199, 101, 41, 45, 213, 98, 224, 200]);

/**
 * è·å–ç”¨æˆ·çš„ PYUSD ATA
 */
export async function getUserPyusdAccount(userPublicKey: PublicKey): Promise<PublicKey> {
  return getAssociatedTokenAddressSync(
    PYUSD_MINT,
    userPublicKey,
    false,
    TOKEN_2022_PROGRAM_ID
  );
}

/**
 * æ£€æŸ¥ PYUSD ä½™é¢
 */
export async function checkPyusdBalance(
  userPublicKey: PublicKey,
  connection: Connection
): Promise<number> {
  try {
    const pyusdAccount = await getUserPyusdAccount(userPublicKey);
    const balance = await connection.getTokenAccountBalance(pyusdAccount);
    return balance.value.uiAmount || 0;
  } catch (error) {
    console.error('è·å– PYUSD ä½™é¢å¤±è´¥:', error);
    return 0;
  }
}

/**
 * åˆ›å»ºå­˜æ¬¾å¹¶è´¨æŠ¼äº¤æ˜“
 */
export async function createDepositAndStakeTransaction(
  userPublicKey: PublicKey,
  amount: number,
  connection: Connection
): Promise<Transaction> {
  console.log('ğŸ—ï¸ æ„å»ºå­˜æ¬¾äº¤æ˜“...', { amount, user: userPublicKey.toString() });

  // åˆå§‹åŒ– SDK
  const rpcUrl = connection.rpcEndpoint;
  const sdkHelper = new KaminoSDKHelper(rpcUrl, userPublicKey);
  await sdkHelper.initialize();

  // ä» SDK è·å–è´¦æˆ·ä¿¡æ¯
  const depositAndStakeInfo = await sdkHelper.getDepositAndStakeInfo(
    PYUSD_VAULT,
    amount
  );

  const { vaultAccounts, remainingAccounts } = depositAndStakeInfo.deposit;
  const { farmAccounts } = depositAndStakeInfo.stake;

  // è·å–ç”¨æˆ·çš„ PYUSD ATA
  const userPyusdAccount = await getUserPyusdAccount(userPublicKey);

  // è½¬æ¢é‡‘é¢ä¸º lamports (6 decimals)
  const amountLamports = Math.floor(amount * 1_000_000);

  // åˆ›å»ºäº¤æ˜“
  const transaction = new Transaction();

  // 1. æ·»åŠ  Compute Budget
  transaction.add(
    ComputeBudgetProgram.setComputeUnitLimit({ units: 400_000 })
  );

  // 2. æ£€æŸ¥å¹¶åˆ›å»º Shares ATAï¼ˆå¦‚æœéœ€è¦ï¼‰
  const accountInfo = await connection.getAccountInfo(vaultAccounts.userSharesAta);
  if (!accountInfo) {
    console.log('âš ï¸ Shares ATA ä¸å­˜åœ¨ï¼Œåˆ›å»ºä¸­...');
    const createAtaIx = createAssociatedTokenAccountInstruction(
      userPublicKey,
      vaultAccounts.userSharesAta,
      userPublicKey,
      vaultAccounts.sharesMint,
      TOKEN_PROGRAM_ID
    );
    transaction.add(createAtaIx);
  }

  // 3. åˆ›å»º kamino_deposit_and_stake æŒ‡ä»¤
  const depositInstruction = createDepositAndStakeInstruction(
    userPublicKey,
    PYUSD_VAULT,
    vaultAccounts,
    farmAccounts,
    userPyusdAccount,
    amountLamports,
    remainingAccounts
  );

  transaction.add(depositInstruction);

  // è®¾ç½®æœ€è¿‘çš„ blockhash
  const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
  transaction.recentBlockhash = blockhash;
  transaction.lastValidBlockHeight = lastValidBlockHeight;
  transaction.feePayer = userPublicKey;

  console.log('âœ… å­˜æ¬¾äº¤æ˜“æ„å»ºå®Œæˆ');
  return transaction;
}

/**
 * åˆ›å»º kamino_deposit_and_stake æŒ‡ä»¤
 */
function createDepositAndStakeInstruction(
  userPublicKey: PublicKey,
  vaultState: PublicKey,
  vaultAccounts: any,
  farmAccounts: any,
  userTokenAta: PublicKey,
  amount: number,
  remainingAccounts: any[]
): TransactionInstruction {
  // åºåˆ—åŒ–é‡‘é¢å‚æ•°
  const amountBuffer = Buffer.alloc(8);
  amountBuffer.writeBigUInt64LE(BigInt(amount), 0);

  const data = Buffer.concat([DISCRIMINATOR_DEPOSIT_AND_STAKE, amountBuffer]);

  const keys = [
    { pubkey: userPublicKey, isSigner: true, isWritable: true },
    { pubkey: vaultState, isSigner: false, isWritable: true },
    { pubkey: vaultAccounts.tokenVault, isSigner: false, isWritable: true },
    { pubkey: vaultAccounts.tokenMint, isSigner: false, isWritable: false },
    { pubkey: vaultAccounts.baseAuthority, isSigner: false, isWritable: false },
    { pubkey: vaultAccounts.sharesMint, isSigner: false, isWritable: true },
    { pubkey: userTokenAta, isSigner: false, isWritable: true },
    { pubkey: vaultAccounts.userSharesAta, isSigner: false, isWritable: true },
    { pubkey: new PublicKey(KLEND_PROGRAM), isSigner: false, isWritable: false },
    { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: EVENT_AUTHORITY, isSigner: false, isWritable: false },
    { pubkey: KAMINO_V2_PROGRAM, isSigner: false, isWritable: false },
    { pubkey: farmAccounts.farmState, isSigner: false, isWritable: true },
    { pubkey: farmAccounts.userFarm, isSigner: false, isWritable: true },
    { pubkey: farmAccounts.delegatedStake, isSigner: false, isWritable: true },
    { pubkey: farmAccounts.farmsProgram, isSigner: false, isWritable: false },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    ...remainingAccounts,
  ];

  return new TransactionInstruction({
    programId: MARS_PROGRAM_ID,
    keys,
    data,
  });
}

/**
 * åˆ›å»ºå–æ¶ˆè´¨æŠ¼å’Œå–æ¬¾çš„ 3 ä¸ªäº¤æ˜“
 */
export async function createUnstakeAndWithdrawTransactions(
  userPublicKey: PublicKey,
  sharesAmount: number,
  connection: Connection
): Promise<Transaction[]> {
  console.log('ğŸ—ï¸ æ„å»ºå–æ¬¾äº¤æ˜“ (3æ­¥)...', { sharesAmount, user: userPublicKey.toString() });

  // åˆå§‹åŒ– SDK
  const rpcUrl = connection.rpcEndpoint;
  const sdkHelper = new KaminoSDKHelper(rpcUrl, userPublicKey);
  await sdkHelper.initialize();

  // ä» SDK è·å–è´¦æˆ·ä¿¡æ¯
  const withdrawInfo = await sdkHelper.getWithdrawAndUnstakeInfo(
    PYUSD_VAULT,
    sharesAmount
  );

  // æ³¨æ„: getWithdrawAndUnstakeInfo è¿”å› DepositAndStakeInfo ç±»å‹
  // deposit å­—æ®µå®é™…åŒ…å« withdraw è´¦æˆ·ä¿¡æ¯
  const { vaultAccounts, remainingAccounts } = withdrawInfo.deposit;
  const { farmAccounts } = withdrawInfo.stake;

  // è½¬æ¢é‡‘é¢ä¸º lamports (6 decimals for shares)
  const amountLamports = Math.floor(sharesAmount * 1_000_000);

  const transactions: Transaction[] = [];

  // è·å–æœ€æ–°çš„ blockhashï¼ˆæ‰€æœ‰äº¤æ˜“å…±äº«ï¼‰
  const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();

  // === äº¤æ˜“ 1: Start Unstake ===
  const tx1 = new Transaction();
  tx1.add(ComputeBudgetProgram.setComputeUnitLimit({ units: 300_000 }));
  tx1.add(
    createStartUnstakeInstruction(
      userPublicKey,
      farmAccounts,
      amountLamports
    )
  );
  tx1.recentBlockhash = blockhash;
  tx1.lastValidBlockHeight = lastValidBlockHeight;
  tx1.feePayer = userPublicKey;
  transactions.push(tx1);

  // === äº¤æ˜“ 2: Unstake ===
  const tx2 = new Transaction();
  tx2.add(ComputeBudgetProgram.setComputeUnitLimit({ units: 300_000 }));
  tx2.add(
    createUnstakeInstruction(
      userPublicKey,
      farmAccounts,
      amountLamports
    )
  );
  tx2.recentBlockhash = blockhash;
  tx2.lastValidBlockHeight = lastValidBlockHeight;
  tx2.feePayer = userPublicKey;
  transactions.push(tx2);

  // === äº¤æ˜“ 3: Withdraw ===
  const userPyusdAccount = await getUserPyusdAccount(userPublicKey);
  const tx3 = new Transaction();
  tx3.add(ComputeBudgetProgram.setComputeUnitLimit({ units: 400_000 }));
  tx3.add(
    createWithdrawInstruction(
      userPublicKey,
      PYUSD_VAULT,
      vaultAccounts,
      userPyusdAccount,
      amountLamports,
      remainingAccounts
    )
  );
  tx3.recentBlockhash = blockhash;
  tx3.lastValidBlockHeight = lastValidBlockHeight;
  tx3.feePayer = userPublicKey;
  transactions.push(tx3);

  console.log('âœ… 3ä¸ªå–æ¬¾äº¤æ˜“æ„å»ºå®Œæˆ');
  return transactions;
}

/**
 * åˆ›å»º start_unstake æŒ‡ä»¤
 */
function createStartUnstakeInstruction(
  userPublicKey: PublicKey,
  farmAccounts: any,
  amount: number
): TransactionInstruction {
  const amountBuffer = Buffer.alloc(8);
  amountBuffer.writeBigUInt64LE(BigInt(amount), 0);
  const data = Buffer.concat([DISCRIMINATOR_START_UNSTAKE, amountBuffer]);

  const keys = [
    { pubkey: userPublicKey, isSigner: true, isWritable: true },
    { pubkey: farmAccounts.farmState, isSigner: false, isWritable: true },
    { pubkey: farmAccounts.userFarm, isSigner: false, isWritable: true },
    { pubkey: farmAccounts.delegatedStake, isSigner: false, isWritable: true },
    { pubkey: farmAccounts.farmsProgram, isSigner: false, isWritable: false },
  ];

  return new TransactionInstruction({
    programId: MARS_PROGRAM_ID,
    keys,
    data,
  });
}

/**
 * åˆ›å»º unstake æŒ‡ä»¤
 */
function createUnstakeInstruction(
  userPublicKey: PublicKey,
  farmAccounts: any,
  amount: number
): TransactionInstruction {
  const amountBuffer = Buffer.alloc(8);
  amountBuffer.writeBigUInt64LE(BigInt(amount), 0);
  const data = Buffer.concat([DISCRIMINATOR_UNSTAKE, amountBuffer]);

  const keys = [
    { pubkey: userPublicKey, isSigner: true, isWritable: true },
    { pubkey: farmAccounts.farmState, isSigner: false, isWritable: true },
    { pubkey: farmAccounts.userFarm, isSigner: false, isWritable: true },
    { pubkey: farmAccounts.delegatedStake, isSigner: false, isWritable: true },
    { pubkey: farmAccounts.farmsProgram, isSigner: false, isWritable: false },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
  ];

  return new TransactionInstruction({
    programId: MARS_PROGRAM_ID,
    keys,
    data,
  });
}

/**
 * åˆ›å»º withdraw æŒ‡ä»¤
 */
function createWithdrawInstruction(
  userPublicKey: PublicKey,
  vaultState: PublicKey,
  vaultAccounts: any,
  userTokenAta: PublicKey,
  amount: number,
  remainingAccounts: any[]
): TransactionInstruction {
  const amountBuffer = Buffer.alloc(8);
  amountBuffer.writeBigUInt64LE(BigInt(amount), 0);
  const data = Buffer.concat([DISCRIMINATOR_WITHDRAW, amountBuffer]);

  const keys = [
    { pubkey: userPublicKey, isSigner: true, isWritable: true },
    { pubkey: vaultState, isSigner: false, isWritable: true },
    { pubkey: vaultAccounts.tokenVault, isSigner: false, isWritable: true },
    { pubkey: vaultAccounts.tokenMint, isSigner: false, isWritable: false },
    { pubkey: vaultAccounts.baseAuthority, isSigner: false, isWritable: false },
    { pubkey: vaultAccounts.sharesMint, isSigner: false, isWritable: true },
    { pubkey: userTokenAta, isSigner: false, isWritable: true },
    { pubkey: vaultAccounts.userSharesAta, isSigner: false, isWritable: true },
    { pubkey: new PublicKey(KLEND_PROGRAM), isSigner: false, isWritable: false },
    { pubkey: TOKEN_2022_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    { pubkey: EVENT_AUTHORITY, isSigner: false, isWritable: false },
    { pubkey: KAMINO_V2_PROGRAM, isSigner: false, isWritable: false },
    ...remainingAccounts,
  ];

  return new TransactionInstruction({
    programId: MARS_PROGRAM_ID,
    keys,
    data,
  });
}
