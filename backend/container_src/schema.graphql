# Mars Vaults V8 - The Graph Protocol Schematype VaultDeposit @entity {

# Generated for Solana Mainnet Substreams  id: ID!

  signature: String!

# Vault Deposit Event  user: Bytes!

type VaultDeposit @entity {  vault: Bytes!

  id: ID!  amount: BigInt!

  signature: String!  sharesReceived: BigInt!

  slot: BigInt!  protocolId: Int!

  timestamp: BigInt!  timestamp: BigInt!

  user: String!  slot: BigInt!

  vault: String!}

  amount: BigInt!

  sharesReceived: BigInt!type VaultWithdraw @entity {

  protocolId: Int!  id: ID!

}  signature: String!

  user: Bytes!

# Vault Withdrawal Event  vault: Bytes!

type VaultWithdrawal @entity {  sharesBurned: BigInt!

  id: ID!  amountReceived: BigInt!

  signature: String!  protocolId: Int!

  slot: BigInt!  timestamp: BigInt!

  timestamp: BigInt!  slot: BigInt!

  user: String!}

  vault: String!

  amountReceived: BigInt!type SwapAndDeposit @entity {

  sharesBurned: BigInt!  id: ID!

  protocolId: Int!  signature: String!

}  user: Bytes!

  vault: Bytes!

# Swap and Deposit Event  fromToken: String!

type SwapAndDeposit @entity {  toToken: String!

  id: ID!  amountIn: BigInt!

  signature: String!  amountOut: BigInt!

  slot: BigInt!  sharesReceived: BigInt!

  timestamp: BigInt!  protocolId: Int!

  user: String!  timestamp: BigInt!

  vault: String!  slot: BigInt!

  fromToken: String!}

  toToken: String!

  amountIn: BigInt!type WithdrawWithSwap @entity {

  amountOut: BigInt!  id: ID!

  sharesReceived: BigInt!  signature: String!

  protocolId: Int!  user: Bytes!

}  vault: Bytes!

  sharesBurned: BigInt!

# Withdraw with Swap Event  targetToken: String!

type WithdrawWithSwap @entity {  amountReceived: BigInt!

  id: ID!  slippageBps: Int!

  signature: String!  timestamp: BigInt!

  slot: BigInt!  slot: BigInt!

  timestamp: BigInt!}

  user: String!

  vault: String!type RebalanceEvent @entity {

  sharesBurned: BigInt!  id: ID!

  targetToken: String!  signature: String!

  amountReceived: BigInt!  vault: Bytes!

  slippageBps: Int!  protocolFrom: Int!

}  protocolTo: Int!

  amountIn: BigInt!

# Vault Rebalance Event  amountOut: BigInt!

type VaultRebalance @entity {  executor: Bytes!

  id: ID!  reason: String!

  signature: String!  timestamp: BigInt!

  slot: BigInt!  slot: BigInt!

  timestamp: BigInt!}

  vault: String!

  protocolFrom: Int!type SwapCostEstimate @entity {

  protocolTo: Int!  id: ID!

  amountIn: BigInt!  fromToken: String!

  amountOut: BigInt!  toToken: String!

  executor: String!  inputAmount: BigInt!

  reason: String!  estimatedOutput: BigInt!

}  priceImpactBps: Int!

  totalFees: BigInt!

# Kamino Finance Deposit  route: [String!]!

type KaminoDeposit @entity {  timestamp: BigInt!

  id: ID!}

  signature: String!

  slot: BigInt!type Vault @entity {

  timestamp: BigInt!  id: ID! # vault address

  user: String!  admin: Bytes!

  vault: String!  baseTokenMint: String!

  amount: BigInt!  sharesMint: String!

  sharesReceived: BigInt!  totalDeposits: BigInt!

  kaminoVault: String!  totalShares: BigInt!

}  apy: BigInt!

  status: VaultStatus!

# Kamino Finance Withdrawal  protocols: [ProtocolAllocation!]!

type KaminoWithdrawal @entity {  feeConfig: FeeConfig!

  id: ID!  createdAt: BigInt!

  signature: String!  lastUpdated: BigInt!

  slot: BigInt!  

  timestamp: BigInt!  # Aggregated metrics

  user: String!  totalVolume24h: BigInt!

  vault: String!  totalVolume7d: BigInt!

  sharesBurned: BigInt!  totalVolume30d: BigInt!

  amountReceived: BigInt!  totalFeesCollected: BigInt!

  kaminoVault: String!  uniqueUsers24h: Int!

}  uniqueUsers7d: Int!

  uniqueUsersTotal: Int!

# Vault State Update Event}

type VaultStateUpdate @entity {

  id: ID!type ProtocolAllocation @entity {

  signature: String!  id: ID! # vault_address + protocol_id

  slot: BigInt!  vault: Vault!

  timestamp: BigInt!  protocolId: Int!

  vault: String!  programId: String!

  totalDeposits: BigInt!  enabled: Boolean!

  totalShares: BigInt!  allocationWeightBps: Int!

  apy: BigInt!  currentAllocation: BigInt!

  activeProtocols: Int!  targetAllocationBps: Int!

  totalUsers: Int!}

}

type FeeConfig @entity {

# Vault State Snapshot (from store)  id: ID! # vault address

type VaultState @entity {  vault: Vault!

  id: ID!  depositFeeBps: Int!

  vault: String!  withdrawFeeBps: Int!

  totalSupply: BigInt!  managementFeeBps: Int!

  totalAssets: BigInt!  performanceFeeBps: Int!

  sharePrice: BigInt!  feeRecipient: Bytes!

  lastUpdated: BigInt!}

}

enum VaultStatus {
  ACTIVE
  PAUSED
  CLOSED
  EMERGENCY
}

type UserPosition @entity {
  id: ID! # user + vault address
  user: Bytes!
  vault: Vault!
  amount: BigInt!
  shares: BigInt!
  timestamp: BigInt!
  totalRewards: BigInt!
  
  # Historical metrics
  totalDeposited: BigInt!
  totalWithdrawn: BigInt!
  realizedPnl: BigInt!
  firstDepositTime: BigInt!
  lastActivityTime: BigInt!
}

type ProtocolPerformance @entity {
  id: ID! # vault_address + protocol_id + date
  vault: Vault!
  protocolId: Int!
  totalDeposits: BigInt!
  totalWithdrawals: BigInt!
  currentApy: BigInt!
  averageApy7d: BigInt!
  totalRewardsGenerated: BigInt!
  date: Int! # Unix timestamp at start of day
}

type VaultAnalytics @entity {
  id: ID! # vault_address + date
  vault: Vault!
  totalVolume24h: BigInt!
  totalVolume7d: BigInt!
  totalVolume30d: BigInt!
  totalFeesCollected: BigInt!
  uniqueUsers24h: Int!
  uniqueUsers7d: Int!
  uniqueUsersTotal: Int!
  protocolPerformance: [ProtocolPerformance!]!
  timestamp: BigInt!
}

type VaultDailySnapshot @entity {
  id: ID! # vault_address + date
  vault: Vault!
  date: Int! # Unix timestamp at start of day
  totalDeposits: BigInt!
  totalShares: BigInt!
  apy: BigInt!
  dailyVolume: BigInt!
  dailyFees: BigInt!
  uniqueUsers: Int!
  protocolAllocations: [BigInt!]! # Array of allocations per protocol
}

type UserDailySnapshot @entity {
  id: ID! # user + vault_address + date  
  user: Bytes!
  vault: Vault!
  date: Int! # Unix timestamp at start of day
  sharesBalance: BigInt!
  tokenBalance: BigInt!
  dailyPnl: BigInt!
  totalRewards: BigInt!
}

type GlobalStats @entity {
  id: ID! # "global"
  totalVaults: Int!
  totalUsers: Int!
  totalValueLocked: BigInt!
  totalVolume: BigInt!
  averageApy: BigInt!
  totalFeesCollected: BigInt!
  lastUpdateTime: BigInt!
}

type EmergencyEvent @entity {
  id: ID!
  signature: String!
  vault: Vault!
  eventType: EmergencyEventType!
  reason: String!
  executor: Bytes!
  timestamp: BigInt!
  slot: BigInt!
}

enum EmergencyEventType {
  PAUSE
  RESUME
  EMERGENCY_WITHDRAW
  FORCE_REBALANCE
}

# Kamino Integration Events

type KaminoDeposit @entity {
  id: ID!
  signature: String!
  user: Bytes!
  vault: Bytes!
  amount: BigInt!
  sharesReceived: BigInt!
  kaminoVault: String!
  timestamp: BigInt!
  slot: BigInt!
}

type KaminoWithdraw @entity {
  id: ID!
  signature: String!
  user: Bytes!
  vault: Bytes!
  sharesBurned: BigInt!
  amountReceived: BigInt!
  kaminoVault: String!
  timestamp: BigInt!
  slot: BigInt!
}

type KaminoStake @entity {
  id: ID!
  signature: String!
  user: Bytes!
  vault: Bytes!
  sharesAmount: BigInt!
  farmAddress: String!
  timestamp: BigInt!
  slot: BigInt!
}

type KaminoUnstake @entity {
  id: ID!
  signature: String!
  user: Bytes!
  vault: Bytes!
  sharesAmount: BigInt!
  farmAddress: String!
  isStart: Boolean!
  timestamp: BigInt!
  slot: BigInt!
}